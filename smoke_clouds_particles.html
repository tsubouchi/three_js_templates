<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Three.js ç…™/é›²ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000;
    }
    canvas { 
      display: block;
      aspect-ratio: 9/16;
      height: 100vh;
      max-height: 100vh;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 8px;
      color: white;
      font-family: Arial, sans-serif;
      transition: opacity 0.3s ease;
    }
    .control-row {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
    }
    .control-row:last-child {
      margin-bottom: 0;
    }
    label {
      width: 80px;
      display: inline-block;
    }
    #speedSlider {
      width: 150px;
      margin: 0 10px;
      vertical-align: middle;
    }
    #colorPicker {
      margin: 0 10px;
      vertical-align: middle;
    }
    #toggleButton {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background 0.3s ease;
    }
    #toggleButton:hover {
      background: rgba(40,40,40,0.8);
    }
    .hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="control-row">
      <label for="speedSlider">ã‚¹ãƒ”ãƒ¼ãƒ‰:</label>
      <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1">
      <span id="speedValue">1.0</span>
    </div>
    <div class="control-row">
      <label for="colorPicker">è‰²:</label>
      <input type="color" id="colorPicker" value="#ffffff">
      <input type="text" id="colorHex" value="#ffffff" style="width: 70px; text-align: center;">
    </div>
  </div>
  
  <button id="toggleButton">âš™ï¸</button>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.module.min.js",
        "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Canvas ã‚µã‚¤ã‚ºè¨­å®šï¼ˆ9:16ã®ç¸¦é•·æ¯”ç‡ã‚’å›ºå®šï¼‰
    const aspectRatio = 9/16;
    const height = window.innerHeight;
    const width = height * aspectRatio;

    // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®è¨­å®š
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    const camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
    camera.position.z = 4;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    
    // OrbitControls ã®è¿½åŠ 
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”¨ã®å††å½¢ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆ
    function createCircleTexture() {
      const canvas = document.createElement('canvas');
      const size = 128;
      canvas.width = size;
      canvas.height = size;
      
      const context = canvas.getContext('2d');
      const centerX = size / 2;
      const centerY = size / 2;
      const radius = size / 2;
      
      context.beginPath();
      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      
      // æ”¾å°„çŠ¶ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
      const gradient = context.createRadialGradient(
        centerX, centerY, 0, centerX, centerY, radius
      );
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
      gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.3)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      
      context.fillStyle = gradient;
      context.fill();
      
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ä½œæˆ
    const particleCount = 9;  // å…ƒã®ã‚³ãƒ¼ãƒ‰ã¨åŒã˜9ã¤ã®ãƒã‚¤ã‚ºã‚½ãƒ¼ã‚¹
    const groups = [];
    let particleColor = new THREE.Color(0xffffff); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è‰²

    function createSmokeCloud(index) {
      const particlesPerCloud = 10000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particlesPerCloud * 3);
      const sizes = new Float32Array(particlesPerCloud);
      const opacities = new Float32Array(particlesPerCloud);
      
      for (let i = 0; i < particlesPerCloud; i++) {
        // ãƒã‚¤ã‚ºé–¢æ•°ã®ä»£ã‚ã‚Šã«ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã§åˆæœŸåŒ–
        const radius = 1.0;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        
        // æ¥µåº§æ¨™ã‹ã‚‰ç›´äº¤åº§æ¨™ã¸å¤‰æ›
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
        
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã”ã¨ã®ã‚µã‚¤ã‚ºã¨ã‚ªãƒ‘ã‚·ãƒ†ã‚£ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«è¨­å®š
        sizes[i] = Math.random() * 0.05 + 0.01;
        opacities[i] = Math.random() * 0.5 + 0.2;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geometry.setAttribute('opacity', new THREE.BufferAttribute(opacities, 1));
      
      // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã®ä½œæˆ
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0.0 },
          cloudIndex: { value: index },
          color: { value: particleColor },
          pointTexture: { value: createCircleTexture() }
        },
        vertexShader: `
          attribute float size;
          attribute float opacity;
          uniform float time;
          uniform float cloudIndex;
          varying float vOpacity;
          
          // 3æ¬¡å…ƒãƒã‚¤ã‚ºé–¢æ•°ã‚’æ¨¡å€£
          float noise(vec3 p) {
            vec3 i = floor(p);
            vec3 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            
            float n = i.x + i.y * 157.0 + i.z * 113.0;
            vec4 v = fract(sin(vec4(n, n + 1.0, n + 113.0, n + 157.0)) * 43758.5453123);
            
            float res = mix(mix(mix(v.x, v.y, f.x), mix(v.z, v.w, f.x), f.y), 
                            mix(mix(v.x, v.y, f.x), mix(v.z, v.w, f.x), f.y) + 0.5, f.z);
            return res;
          }
          
          void main() {
            vOpacity = opacity;
            
            // æ™‚é–“ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«åŸºã¥ã„ãŸå‹•ãã‚’è¿½åŠ 
            float noiseFreq = 0.4;
            float noiseAmp = 1.0;
            float baseFreq = cloudIndex * 0.1 + time * 0.05;
            
            vec3 noisePos = position;
            float noise1 = noise(vec3(noisePos.x * noiseFreq + baseFreq, 
                                    noisePos.y * noiseFreq + baseFreq, 
                                    noisePos.z * noiseFreq + time * 0.1));
            float noise2 = noise(vec3(noisePos.y * noiseFreq + baseFreq, 
                                    noisePos.z * noiseFreq + baseFreq, 
                                    noisePos.x * noiseFreq + time * 0.1));
            float noise3 = noise(vec3(noisePos.z * noiseFreq + baseFreq, 
                                    noisePos.x * noiseFreq + baseFreq, 
                                    noisePos.y * noiseFreq + time * 0.1));
            
            vec3 offset = vec3(noise1, noise2, noise3) * noiseAmp;
            vec3 newPosition = position + offset;
            
            // é›²ã®ä¸­å¿ƒä½ç½®ã‚’ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            vec3 centerOffset = vec3(
              sin(time * 0.2 + cloudIndex) * 1.5,
              cos(time * 0.3 + cloudIndex * 0.7) * 1.5,
              sin(time * 0.4 + cloudIndex * 1.4) * 1.5
            );
            
            vec4 mvPosition = modelViewMatrix * vec4(newPosition + centerOffset, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            // ã‚«ãƒ¡ãƒ©ã‹ã‚‰ã®è·é›¢ã«åŸºã¥ã„ã¦ã‚µã‚¤ã‚ºã‚’èª¿æ•´
            gl_PointSize = size * (300.0 / -mvPosition.z);
          }
        `,
        fragmentShader: `
          varying float vOpacity;
          uniform vec3 color;
          uniform sampler2D pointTexture;
          
          void main() {
            // å††å½¢ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ç”¨ã—ã¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æç”»
            vec4 texColor = texture2D(pointTexture, gl_PointCoord);
            gl_FragColor = vec4(color, vOpacity * texColor.a);
          }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      return { particles, material };
    }
    
    // ç…™/é›²ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
    for (let i = 0; i < particleCount; i++) {
      groups.push(createSmokeCloud(i));
    }
    
    // UI ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    const colorPicker = document.getElementById('colorPicker');
    const colorHex = document.getElementById('colorHex');
    const controlsPanel = document.getElementById('controls');
    const toggleButton = document.getElementById('toggleButton');
    
    let timeSpeed = parseFloat(speedSlider.value);
    let controlsVisible = true;
    
    // ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    toggleButton.addEventListener('click', function() {
      controlsVisible = !controlsVisible;
      if (controlsVisible) {
        controlsPanel.classList.remove('hidden');
        toggleButton.textContent = 'âš™ï¸';
      } else {
        controlsPanel.classList.add('hidden');
        toggleButton.textContent = 'ğŸ‘ï¸';
      }
    });
    
    // ã‚¹ãƒ”ãƒ¼ãƒ€ãƒ¼åˆ¶å¾¡
    speedSlider.addEventListener('input', function() {
      timeSpeed = parseFloat(this.value);
      speedValue.textContent = timeSpeed.toFixed(1);
    });
    
    // ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    colorPicker.addEventListener('input', function() {
      const color = this.value;
      colorHex.value = color;
      updateParticleColor(color);
    });
    
    // 16é€²æ•°ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    colorHex.addEventListener('change', function() {
      let color = this.value;
      // #ãŒãªã„å ´åˆã¯è¿½åŠ 
      if (!color.startsWith('#')) {
        color = '#' + color;
        this.value = color;
      }
      // æœ‰åŠ¹ãª16é€²æ•°ã‹ãƒã‚§ãƒƒã‚¯
      if (/^#[0-9A-F]{6}$/i.test(color)) {
        colorPicker.value = color;
        updateParticleColor(color);
      } else {
        // ç„¡åŠ¹ãªå ´åˆã¯ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã®å€¤ã«æˆ»ã™
        this.value = colorPicker.value;
      }
    });
    
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è‰²ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
    function updateParticleColor(hexColor) {
      // THREE.Colorã«å¤‰æ›
      particleColor.set(hexColor);
      
      // å„ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒãƒ†ãƒªã‚¢ãƒ«ã‚«ãƒ©ãƒ¼ã‚’æ›´æ–°
      groups.forEach(group => {
        group.material.uniforms.color.value = particleColor;
      });
    }
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      
      // ã‚¹ãƒ”ãƒ¼ãƒ‰è¨­å®šã«åŸºã¥ã„ã¦ã‚¿ã‚¤ãƒ ã‚¹ãƒ†ãƒƒãƒ—ã‚’èª¿æ•´
      time += 0.005 * timeSpeed;
      
      // å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®ã‚¿ã‚¤ãƒ ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã‚’æ›´æ–°
      groups.forEach(group => {
        group.material.uniforms.time.value = time;
      });
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œï¼ˆ9:16ã®ç¸¦é•·æ¯”ç‡ã‚’ç¶­æŒï¼‰
    window.addEventListener('resize', () => {
      const aspectRatio = 9/16;
      const newHeight = window.innerHeight;
      const newWidth = newHeight * aspectRatio;
      
      camera.aspect = aspectRatio;
      camera.updateProjectionMatrix();
      
      renderer.setSize(newWidth, newHeight);
    });
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚¿ãƒ¼ãƒˆ
    animate();
  </script>
</body>
</html>